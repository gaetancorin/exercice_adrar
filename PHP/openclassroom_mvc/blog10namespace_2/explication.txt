///// V2= UN CONTROLLER + +model+views
création fonctionnement MVC avec
index.php est le controller
model.php dans le dossier src est le modèle
homepage.php dans le dossier template est la vue

---- On crée un controller index.php qui affiche les différents articles--- 
Le controller index.php appelle une fonction dans le modèle.
(cette fonction va chercher les articles dans la bdd et les retourne en format tableau)
Le résultat est stocker dans une variable dans le controller
On fournis la variable au template qui itère les articles et les affiche.


/////// V3= UN 2EME CONTROLLER AVEC PARAMETRE PASSÉ DANS SON URL
(le controller index.php récupère désormais l'id des articles et le transmet à son template.
Le template crée un bouton commentaire sous chaque article. Ce bouton fait une requête vers le nouveau controller post.php avec l'id en paramètre dans l'url )

---- On crée un controller post.php qui affiche les commentaires de 1 article ----
Ce controller récupère le paramètre id passé dans l"url.
Il appelle la fonction getPost() qui récupère les informations de l'article ayant le même id que celui passé en paramètre. 
Il appelle la fonction getComments() qui récupère les informations des commentaires ayant une clé étrangère avec le même id que celui passé en paramètre.

Il appelle son template post.php qui affiche l'article et les commentaires de cet article

////// V4= TEMPLATE UTILISANT UN LAYOUT
(le layout est un template avec des variable vide. Il est relié à un autre template qui lui donne les valeurs de variable)

on crée un layout layout.php qui a deux variables vide($title et $content)
la template homepage.php va lui fournir la variable $title, puis va récupérer l'ensemble de son html et va le mettre dans la variable $content.
puis il va require le layout qui affichera son contenu avec les variables fournis

/////// V5= INSTALLATION DU ROUTEUR
La page index.php sera notre routeur.
Les controllers sont désormais rangé dans src/controllers .
Les fichiers controllers ne font plus aucune action. Ils sont désormais des points d'accès afin que le routeur puisse accéder à leur fonction.
L'intégralité des actions qu'ils faissaient avant sont désormais dans leur fonction.
Les require() dans les controllers deviennent des require_once() pour éviter les doublons.
Si un controller nécessite un ID, il faut lui fournir dans le paramètre de sa fonction

Pour passer d'une page à l'autre, on intègre le paramètre 'action' dans l'url en méthode get. Tous les urls seront donc 'index?action=(CONTROLLER)' ou 'index?action=(CONTROLLER)&id=(ID)'.
Le routeur va require toutes les pages controllers, vérifier l'action et l'id passé en paramètre dans l'url et démarrer la fonction du bon controller avec des principes de if/else.
!Attention! Il ne faut pas mettre de point dans le nom des pages

//////// v6 = AJOUT DU CONTROLLER ADDCOMMENT (correction)
(la fonction getComments à été déplacé de models.php à comment.php pour des raisons de logique métier)
On ajoute un formulaire au template post.php pour laisser à l'utilisateur la posibilité d'ajouter un commentaire sur un article. Il prend en méthode get l'action addComment et l'id de l'article, et en méthode post le contenu du formulaire.
On crée un routeur qui vérifie l'action et l'id et renvois sur le controller addComment.
Ce controller vérifie les données du formulaire et appelle la fonction createComment du modèle comment pour créer la nouvelle table.
Le controller vérifie que la création a bien été effectué, puis renvois vers le controller post.php ou l'utilisateur pourra voir son commentaire.

//////// v7 = Attraper les Exception grace au routeur
Lorsque le routeur appelle un controller, il appelle sa fonction, l'action reste donc dans le routeur.
Lorsque le controller appelle un modèle, il appelle une fonction, l'action se passe donc encore dans le routeur
En placant un try/catch sur tout le routeur de index.php, on a donc la possibilité de récupérer toutes les exceptions des controllers et des modèles.
Les problèmes de connection en bdd renvoyant des exceptions, on peut même enlever le try catch de l'appel à la bdd, puisqu'il peut être capturer par le routeur.

On crée le template error.php et on l'affiche lorsque l'on catch une erreur. 

//////// v8 = modèle en POO
Il y a désormais une déclaration de class 'Comment' dans le modèle comment.php.
La fonction getComments() est modifié pour retourner un tableau d'instances 'Comment' au lieu d'un tableau de dictionnaire comme précédemment. Mais ce n'est pas encore une méthode d'instance.
Le template post.php est modifié pour que lorsqu'il parcours le tableau de commentaires, il récupère les attributs d'instances.

Le fichier de modèle modele.php est rangé dans le dossier modèle et s'appelle désormais post.php car il ne contient que des logiques métiers de post. Les require de ce fichier sont donc changé dans les controllers.

Même opération que dans v8 mais pour le modèle post.php(ajout de la class post et adaptation des fonction de son controller et templates en adéquation à ce changement)

//////// v9 = ENCAPSULATION_1
Si un controller appelle plusieurs fonctions du modèle post.php, la bdd sera appelé à chaque fonction. C'est une tache longue que l'on va essayer d'éviter de répéter.

Dans le modèle post.php, on va donc créer une class 'PostRepository' qui prend en attribut la connection de la bdd. Cette attribut aura une valeur null lorsque on l'instancie.
On crée une fonction 'dbConnect' qui prend en paramètre la class PostRepository et qui assigne la connection à la bdd dans sa variable uniquement si elle à une valeur null.

Puis dans chaque fonction de notre modèle:
- On donne en paramètre la class 'PostRepository'.
- On exécute la fonction dbConnect avec 'PostRepository' en argument pour vérifier/créer la connection à la bdd.
- On se sert enfin de l'attribut de 'PostRepository' pour faire nos requête en bdd.

Dans chaque controller utilisant le modèle post.php, il faut penser à instancier 'PostRepository', et à la donner en argument sur chaque fonction que l'on appelle de ce modèle.

//////// v9 = ENCAPSULATION_2
Sur le modèle post.php, toutes les fonctions prennent comme argument la class 'PostRepository' qui correspond à la connection à notre bdd. On dit qu'ils utilisent le même contexte.
On va donc pouvoir encapsuler ses fonctions avec la class 'PostRepository'.
Autrement dit, on déplace tous nos fonctions dans notre class 'PostRepository' pour qu'ils deviennent des méthodes de cette class et hérite donc de son attribut(la connection bdd) 

Toutes nos fonctions dans le modèle post.php sont maintenant devenu des méthodes de l'encapsulation 'PostRepository'.
La syntaxe pour utiliser la méthode 'dbConnect' dans nos autres méthodes de 'PostRepository' changent car l'encapsulation doit désormais s'appeller elle-même pour accéder à ses autres méthodes(this->dbConnect)
Il faut aussi changer la syntaxe dans les controllers. On n'appelle plus une fonction avec la class 'PostRepository' en argument mais bien une méthode de 'PostRepository'.

EXPLICATION DIRECT ENCAPSULATION_2= 
Si un controller appelle plusieurs fonctions du modèle post.php, la bdd sera appelé à chaque fonction. C'est une tache longue que l'on va essayer d'éviter de répéter.

On va donc créer une class 'PostRepository' qui prend en attribut la connection de la bdd. Cette attribut aura une valeur null lorsque on l'instancie.

On déplace l'intégralité des fonctions de post.php dans la class pour qu'ils deviennent des méthodes de cette class et puissent hériter de son attribut.(la connection à la bdd).
On crée dans la class une méthode 'dbConnect' qui assigne la connection à la bdd dans l'attribut de son encapsulation uniquement si cette attribut a une valeur null.

On modifie les fonctions des controllers utilisant le modèle post.php.
On commence par instancier notre encapsulation, puis on appelle la méthode de cette encapsulation(au lieu d'appeller directement une fonction).

Félicitation ! Désormais, la connection à la bdd se fera à l'appelle de la première méthode de l'encapsulation, puis la gardera dans son attribut pour les méthodes suivantes de cette encapsulation!

//////// v9 = ENCAPSULATION_3
Lorsque on appelle différentes encapsulations dans un même controller, la connection à la bdd se fait à chaque encapsulation. On veut que la connection ne se fasse qu'une fois par controller.
Pour cela, on va externaliser la méthode 'dbConnect' du modèle post.php pour en faire un objet séparer. 
Le but étant qu'elle garde en mémoire la connection de la bdd et qu'elle puisse être accessible dans les différentes encapsulations.
On crée donc une class qui aura comme attribut la connection de la bdd. Cette attribut aura une valeur null lorsque on l'instancie. 
On crée dans cette class une méthode 'getConnection' qui assigne la connection de la bdd dans son attribut uniquement si cette attribut a une valeur null, puis retourne l'attribut. 
Cette nouvelle class, que l'on va nommer 'DatabaseConnection' et ranger dans le dossier src/lib/, devra être instancié dans le controller. 
Cette instance sera ensuite fournis aux différentes encapsulations du controller en étant assigné à un attribut sur chacune de ses encapsulations utile au controller.
Le but étant que toutes les encapsulations puissent accéder à la bdd en utilisant la même instance de 'DatabaseConnection' qui est assigné à leur attribut.
A chaque requete bdd dans une encapsulation, il faudra penser à réucupérer dans son attribut l'instance 'DatabaseConnection' et déclencher la méthode d'instance 'getConnection' qui crée la connection si elle ne l'as encore jamais faite, puis la retourne.
($this->connection->getConnection())
Il faut aussi penser à require le fichier database.php sur chaque modèle qui utilise cette bdd.

//////// v9 = ENCAPSULATION_4
on fait pareil que encapsulation_3 pour le modèle comment.php

//////// v10= Namespace_1
Afin d'éviter les conflits entre les noms de classe(et les encapsulations), nous allons utiliser des namespaces. Le but étant de changer chaque nom de classe en espace de nom. 
Ainsi, pour déclarer un namespace dans le modèle post.php, il faut le déclarer en haut du fichier post.php. Le namespace prendra comme nom l'aborescence du fichier.
( namespace Application\Model\Post; )

Par défault, lorsqu'un fichier est dans un namespace comme dans le modèle post.php, l'intégralité des class appelé dans ce fichier seront recherché dans le namespace global, sois dans le fichier, ou encore Application\Model\Post.

Pourtant, dans notre encapsulation 'PostRepository', nous définisons une variable avec comme type la classe 'DatabaseConnection'.
Cette classe ne fait pas partie du modèle post.php. 
Pour pouvoir référencer correctement notre type de class 'DatabaseConnection' depuis l'espace global(namespace global), il suffit de rajouter un antislash \DatabaseConnection


Retournons désormais au controller post.php.
Pour créer la class 'PostRepository' contenue dans le modèle post.php, il faut désormais l'appeller par son nouveau nom, sois, son namespace !'
( $postRepository = new \Application\Model\Post\PostRepository(); )
C'est un peu long à écrire. Nous allons donc le renommer dans notre controller !(oui encore...)
En inscrivant 'use \Application\Model\Post\PostRepository;' dans le controller,  j'indique à mon controller d'utiliser \Application\Model\Post\PostRepository à chaque fois que j'appelle une class PostRepository avec la syntaxe 'PostRepository'.

Je peut même le renommer une troisième fois(youhou !) avec le mot clé 'as' .
ex: 'use \Application\Model\Post\PostRepository as john;'
et $PostRepository = new john();

//////// v10= Namespace_2
Voici la marche a suivre pour que toutes les pages dans le src ai leurs namespace=
Les namespace déjà présent dans le modèle post.php et les 'use' du controller post.php ont était changé pour retirer 'src' des namespace.
Dans le modèle comment, il faut apporter les même modifications que celle déjà réalisé sur  post.php.
Dans lib/database, ajouter le namespace. La subtilité est de rajouter les antislashs sur PDO.
Vous venez de donner un namespace a DatabaseConnection
il faut maintenant modifier les modèles en enlevant les antislash sur la DatabaseConnection
Il faut aussi penser à 'use' la databse dans kes modèles.
Il faut 'use' les modèles et la database dans les controllers.

nous avons un site fonctionnel avec les models et database en namespace.
Désormais, nous allons passer les controller en namespace.
Pour cela, nous allons encapsuler les fonctions des controllers avec une class du même nom que la fonction.
la fonction, désormais méthode, sera renommé execute() avec les variables dans la méthode si il y en a.
Désormais, occupons nous du routeur index.php.
Il faut 'use' tous nos controllers dans le routeur.
Les fonctions de controllers utilisés dans le routeur doivent désormais être changé.
La fonction Post($identifier) devient donc (new Post())->execute($identifier) et ainsi de suite pour les autres fonctions des controllers.
Voila ca marche. Normalement...


